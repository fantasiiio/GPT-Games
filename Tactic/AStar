import matplotlib.pyplot as plt
import numpy as np

# Define the Node class (as previously detailed)
class Node:
    def __init__(self, x, y, walkable=True):
        self.screen_x = x
        self.screen_y = y
        self.walkable = walkable

        self.parent = None
        self.g = float('inf')  # cost from start
        self.h = 0  # heuristic cost to target
        self.f = 0  # total cost (g + h)

    def __eq__(self, other):
        return self.screen_x == other.x and self.screen_y == other.y


# Define helper functions (as previously detailed)
def get_neighbors(node, grid):
    neighbors = []
    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:  # Up, Right, Down, Left
        x, y = node.x + dx, node.y + dy
        if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y].walkable:
            neighbors.append(grid[x][y])
    return neighbors

def manhattan_distance(start, end):
    return abs(start.x - end.x) + abs(start.y - end.y)

# Define A* algorithm (as previously detailed)
def a_star(start_node, end_node, grid):
    open_list = [start_node]
    closed_list = []

    start_node.g = 0
    start_node.h = manhattan_distance(start_node, end_node)
    start_node.f = start_node.g + start_node.h

    while open_list:
        current_node = min(open_list, key=lambda node: node.f)
        open_list.remove(current_node)
        closed_list.append(current_node)

        if current_node == end_node:
            path = []
            while current_node:
                path.append((current_node.x, current_node.y))
                current_node = current_node.parent
            return path[::-1]  # Return reversed path

        for neighbor in get_neighbors(current_node, grid):
            if neighbor in closed_list:
                continue
            
            tentative_g = current_node.g + 1
            if neighbor not in open_list:
                open_list.append(neighbor)
            elif tentative_g >= neighbor.g:
                continue

            neighbor.parent = current_node
            neighbor.g = tentative_g
            neighbor.h = manhattan_distance(neighbor, end_node)
            neighbor.f = neighbor.g + neighbor.h

    return None

# Create a grid with some obstacles
grid_size = 10
grid = [[Node(x, y) for y in range(grid_size)] for x in range(grid_size)]

# Mark some nodes as obstacles
# for i in range(3, 7):
#     grid[i][5].walkable = False

# Define start and end nodes
start = grid[2][2]
end = grid[8][8]

# Get the path using A* algorithm
path = a_star(start, end, grid)

# Draw the grid, obstacles, and path
def visualize_grid(grid, path, start, end):
    data = np.zeros((len(grid), len(grid[0])), dtype=int)
    
    # Fill in obstacles
    for x in range(len(grid)):
        for y in range(len(grid[0])):
            if not grid[x][y].walkable:
                data[x][y] = -1
                
    # Fill in path
    for x, y in path:
        data[x][y] = 2
        
    # Mark start and end
    data[start.x][start.y] = 3
    data[end.x][end.y] = 4
    
    # Draw using matplotlib
    fig, ax = plt.subplots(figsize=(8, 8))
    cmap = plt.get_cmap('terrain')
    ax.imshow(data, cmap=cmap)
    ax.set_xticks(np.arange(len(grid)+1)-.5, minor=True)
    ax.set_yticks(np.arange(len(grid[0])+1)-.5, minor=True)
    ax.grid(which="minor", color="gray", linestyle='-', linewidth=2)
    ax.tick_params(which="minor", size=0)
    plt.xticks([])
    plt.yticks([])
    
    # Custom legend
    from matplotlib.patches import Patch
    legend_elements = [Patch(facecolor=cmap(0.5), edgecolor='gray', label='Obstacle'),
                       Patch(facecolor=cmap(0.75), edgecolor='gray', label='Path'),
                       Patch(facecolor=cmap(1.0), edgecolor='gray', label='Start/End')]
    ax.legend(handles=legend_elements, loc='upper left')
    
    plt.show()

# Visualize the result
visualize_grid(grid, path, start, end)
